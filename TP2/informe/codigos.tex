\section{CÃ³digos}

\subsection{main.py}
%aca va el codigo
\begin{lstlisting}[caption=main.py]
from hebbian import red_hebbiana
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from pylab import Line2D, plot, axis, show, pcolor, colorbar, bone, savefig
import pylab as plt
import sys
import os
import time
import cPickle

#Ejercicio 1
def test_y_graficar(red,resultados, metodo=0, load=False):
	fig = plt.figure()
	ax = fig.add_subplot(111, projection='3d')

	colors = ['b', 'g', 'r', 'c', 'm', 'y', 'k', 'b', 'g', 'r', 'c', 'm', 'y', 'k']
	
	for i in xrange(len(resultados)):
		data = resultados[i]
		res=red.activate(np.array(data[1:]).reshape((1, 856)))
		if not load:
			if i >= 600:
				ax.scatter([res[0][0]],[res[0][1]],[res[0][2]], marker="o", c=colors[data[0] - 1], s=20*4)
			else:
				ax.scatter([res[0][0]],[res[0][1]],[res[0][2]], marker="v", c=colors[data[0] - 1], s=20*4)
		else:
			ax.scatter([res[0][0]],[res[0][1]],[res[0][2]], marker="o", c=colors[data[0] - 1], s=20*4)
			
	timestr = time.strftime("%Y%m%d-%H%M%S")
	dirpath = "imgs/ej1/"+str(metodo)+"/"+timestr
	if not os.path.exists(dirpath):
		os.makedirs(dirpath)
	
	for ii in xrange(0,360, 40):
		ax.azim = ii 		
		savefig(dirpath+"/slice%d.png" %ii)

	# plt.show()


def load_Ej1(Dataset,Net):
	print "Cargando Red"
	with open(Net, "rb") as input:
		red = cPickle.load(input)
	dataset=(np.genfromtxt(Dataset,dtype=int, delimiter=',',usecols=range(0,857))).tolist()
	test_y_graficar(red,dataset, load=True)


def train_Ej1(Dataset,save_file,out_space,lrate,max_epochs,metodo):
	print "Entrenando " + str(max_epochs) + ' epocas y ' +' lrate: ' + str(lrate) +'\nreduciendo a '+str(out_space)+' dimensiones'
	if(metodo):
		print "Usando Oja"
	else:
		print "Usando Sanger"
	dataset=(np.genfromtxt(Dataset,dtype=int, delimiter=',',usecols=range(0,857))).tolist()

	traindataset = [ np.array(data[1:]).reshape((1, 856)) for data in dataset ] #quito la informacion sobre el tipo de dato

	hnn=red_hebbiana(856, out_space,lrate,metodo)
	convergio = hnn.train(traindataset[:600], max_epochs)

	if convergio:
		test_y_graficar(hnn,dataset, metodo)
	if(save_file!=None):
		print "Guardando Red"
		with open(save_file, "wb") as output:
			cPickle.dump(hnn, output, cPickle.HIGHEST_PROTOCOL)
	return convergio

def pruebas(dataset,save_file,max_epochs=5000):
	best_params_oja = []
	best_params_sanger = -1
	for m in [0, 1]:
		for lrate in np.linspace(0.001, 0.1, 20):
			convergio = train_Ej1(dataset, save_file, 3, lrate, max_epochs,m)
			if convergio and not m:
				best_params_sanger = lrate
				break
			if convergio and m:
				best_params_oja.append(lrate)
	return best_params_sanger, best_params_oja





args = sys.argv
usage1 = "\nPara entrenar desde un dataset y guardar la red:\n\
python main.py nomDataset nomRedOut -train lrate epochs metodo out_space \n\
metodo -o para usar oja -s para usar sanger"
usage2= "\nPara cargar una red entrenada y testearla contra un dataset:\n\
python main.py nomDataset normRedIn -load\n"
usage3="Asume el dataset sigue la forma 'categoria, valor1, ... , valor856'"

if(len(args)<4):
	print usage1
	print usage2
	print usage3
	sys.exit()
nomDataset = args[1]
nomRed = args[2]
operacion= str(args[3])
#default value
epochs=int(1000)
lrate=float(0.0001)
metodo=1
out_space=int(3)
if operacion == "-train":
	# Entrenar
	if(len(args)>8):
		print usage1
		print usage3
		sys.exit()	
	if(len(args)>4):
		lrate = float(args[4])
	if(len(args)>5):
		epochs = int(args[5])
	if(len(args)>6):
		if(str(args[6])=="-o"):
			metodo=1
		elif(str(args[6])=="-s"):
			metodo=0
		else:
			print usage1
			print usage3
			sys.exit()
	if(len(args)>7):
		out_space=int(args[7])

	train_Ej1(nomDataset,nomRed,out_space,lrate,epochs,metodo)

elif operacion == "-load":
	# Cargar y testear.
	if(len(args)!=4):
		print usage2
		print usage3
		sys.exit()
	load_Ej1(nomDataset,nomRed)
elif operacion == "-pruebas":
	print pruebas(nomDataset, nomRed)
else:
	print usage1
	print usage2
	print usage3


	
\end{lstlisting}


\subsection{main2.py}
%aca va el codigo
\begin{lstlisting}[caption=main.py]
import matplotlib.pyplot as plt
from kohonen import som
import numpy as np
import matplotlib.cm as mmc
import sys
import os
import cPickle

def prueba():
	file="tp2_training_dataset.csv"
	train_data = np.genfromtxt(file, delimiter=',',usecols=range(1,857))
	train_data=train_data[:600]
	test_data  = np.genfromtxt(file, delimiter=',',usecols=range(0,857))
	if not os.path.exists("imgs/ej2"):
		os.makedirs("imgs/ej2")
	for epoca in [5,10,25,100,500,1000,1500]:
		for M in [3,5,9,20,30,40]:
			for sigma in np.linspace(0.001, 5, 5):
				img_name="imgs/ej2/train_M_"+str(M)+"_sigma_"+str(sigma)+"_epocas_"+str(epoca)+".png"
				print img_name
				red = som(M, M,sigma)
				red.train(train_data,epoca,1)
				graficador(red,test_data[:600],img_name)
				img_name="imgs/ej2/test_M_"+str(M)+"_sigma_"+str(sigma)+"_epocas_"+str(epoca)+".png"
				graficador(red,test_data[600:],img_name)

def graficador(red,dataset,save_img=None):
	color = [[dict() for _ in xrange(red.M2)] for _ in xrange(red.M1)]
	for data in dataset:
		pos=red.test(data[1:].reshape((1,856)))
		d = color[pos[0]][pos[1]]
		if (int(data[0])-1) in d:
			d[int(data[0])-1] += 1
		else:
			d[int(data[0])-1] = 1

	for i in xrange(red.M1):
		for j in xrange(red.M2):
			d = color[i][j]
			if d == {}:
				color[i][j] = 9
			else:
				most_repeated = max(d.iterkeys(), key=(lambda key: d[key]))
				color[i][j] = most_repeated

	cmap = mmc.get_cmap(name="nipy_spectral", lut=10)
	color=np.asarray(color)
	plt.pcolor(color, cmap=cmap)
	plt.title('Resultado')

	# y, x = np.mgrid[slice(0, red.M2),slice(0, red.M1)]
	# plt.subplot(2, 2, 1)
	# plt.pcolor(x, y, color, cmap=cmap)
	# plt.axis([x.min(), x.max(), y.min(), y.max()])

	plt.colorbar()

	if(save_img==None):
		plt.show()
	else:
		plt.savefig(save_img)
	plt.close() 

#Ejercicio 2
def train_Ej2(Dataset,save_file,sigma0,M1,M2,max_epochs,mode):
	print "Entrenando con " + str(epochs) + ' epochs - ' + ' sigma: ' + str(sigmaInicial) 
	data = np.genfromtxt(Dataset, delimiter=',',usecols=range(1,857))
	s = som(M1, M2,sigma0)
	s.train(data, epochs,mode)
	if(save_file!=None):
		print "Guardando red"
		with open(save_file, "wb") as output:
			cPickle.dump(s, output, cPickle.HIGHEST_PROTOCOL)
	test_data = np.genfromtxt(Dataset, delimiter=',',usecols=range(0,857))
	graficador(s,test_data)


def load_Ej2(file,Net):
	print "Cargando red"
	with open(Net, "rb") as input:
		red = cPickle.load(input)
	print "Generando mapa de caracteristicas"
	dataset = np.genfromtxt(file, delimiter=',',usecols=range(0,857))
	graficador(red,dataset)


args = sys.argv
usage1 = "\nPara entrenar desde un dataset y guardar la red:\n\
python main.py nomDataset nomRedOut -train sigmaInicial M1 M2 epochs mode\n"
usage2= "\nPara cargar una red entrenada y testearla contra un dataset:\n\
python main.py nomDataset normRedIn -load\n"
usage3="Asume el dataset sigue la forma 'categoria, valor1, ... , valor856'"

#default value
sigmaInicial=float(5)
epochs=100
X=30
Y=30

if(len(args)==2 and args[1]=="-prueba"):
	prueba()
	sys.exit()
elif(len(args)<4):
	print usage1
	print usage2
	print usage3
	sys.exit()
nomDataset = args[1]
nomRed = args[2]
operacion= str(args[3])
mode=1
if operacion == "-train":
	# Entrenar
	if(len(args)>9):
		print usage1
		print usage3
		sys.exit()
	if(len(args)>4):
		sigmaInicial = float(args[4])
	if(len(args)>5):
		X = int(args[5])
	if(len(args)>6):
		Y = int(args[6])
	if(len(args)>7):
		epochs = int(args[7])
	if(len(args)>8):
		mode = int(args[8])
	train_Ej2(nomDataset,nomRed,sigmaInicial,X,Y,epochs,mode)

elif operacion == "-load":
	# Cargar y testear.
	if(len(args)!=4):
		print usage1
		print usage3
		sys.exit()
	load_Ej2(nomDataset,nomRed)
else:
	print usage1
	print usage2
	print usage3

""" Testeos.
N = 856
M1 = 20
M2 = 20

for epochs in [5, 20, 100]:
	
	for sigma in [0.5, 1.0, 5.0, 10.0]:
		for lrate in [0.5, 1.0, 2.0]:
"""
\end{lstlisting}




\subsection{hebbian.py}
%aca va el codigo
\begin{lstlisting}[caption=main.py]
import numpy as np
import time
import sys

class red_hebbiana:

    def __init__(self, ninputs, noutputs, learning_rate=None, use_oja=True, optimized=True):

        self.learning_rate = learning_rate
        self.use_oja = use_oja
        self.optimized = optimized
        self.ninputs = ninputs
        self.noutputs = noutputs
        self.weights = np.random.uniform(-0.5, 0.5, (ninputs, noutputs))

    def activate(self, x):

        y = np.dot(x, self.weights)
        return y

    def train(self, dataset, epochs):
        # TODO: En vez de epochs, agregar ortogonalidad como criterio de parada
        e = 0
        while not self.isOrtogonal() and e<epochs:
            learning_rate = self.learning_rate or (0.5 / e)

            for x in dataset:
                y = np.dot(x,self.weights)
                if self.optimized:
                    if self.use_oja:
                        x_mono = np.dot(y, self.weights.T)
                        dw = learning_rate * np.dot((x - x_mono).T, y)
                    else:
                        U = np.triu(np.ones((self.noutputs,self.noutputs)))
                        x_mono = np.dot(self.weights, np.multiply(y.T, U))
                        dw = learning_rate * np.multiply((x.T - x_mono),y)
                else:
                    dw = np.zeros((self.ninputs, self.noutputs), dtype=float)

                    for j in range(0, self.noutputs):
                        for i in range(0, self.ninputs):
                            x_mono = 0
                            for k in range(0, self.use_oja and self.noutputs or (j + 1)):
                                x_mono += y[k] * self.weights[i][k]

                            dw[i][j] = learning_rate * (x[i] - x_mono)* y[j] 

                self.weights += dw
            if(e%30==0): 
                print "epoca: "+str(e)
            e += 1
        return self.isOrtogonal()

    def isOrtogonal(self):
        prod = np.dot(self.weights.T, self.weights)
        # print prod
        return np.allclose(prod, np.identity(self.noutputs), atol=0.025)



\end{lstlisting}


\subsection{kohonen.py}
%aca va el codigo
\begin{lstlisting}[caption=main.py]
from math import exp, sqrt
import numpy as np

class som():

    #def __init__(self, ninputs, output_size, learning_rate, sigma):
    def __init__(self, M1,M2, sigma):
        self.sigma_zero = sigma
        self.M1=M1
        self.M2=M2
        self.alfa=1
        self.sigma_r=0.5
        self.noutputs = M1 *M2
        self.filas = np.arange(M1)
        self.columnas = np.arange(M2)  
        

    def activate(self, x):
        y_mono = np.linalg.norm(x.T-self.weights, None, axis=0)

        y = (y_mono == y_mono.min())*1

        return np.reshape(y,(1,self.noutputs))

    def gauss(self, p_j, sigma):

        den = 2 * (sigma**2)

        filas = np.exp(-(self.filas-p_j[0])**2/den)
        columnas = np.exp(-(self.columnas-p_j[1])**2/den)        
        d_matriz = np.outer(filas, columnas)

        return np.reshape(d_matriz,(1, self.noutputs)) ##### CONSULTAR -> OK
        

    def pIndexAlMapa(self, index):
        return (index / self.M2, index % self.M2)
        
    def pIndexDesdeMapa(self, x, y):
        return x*self.M2 + y%self.M2
    
    def correction(self, x,learning_rate, sigma,y):
        jasterisk = np.argmax(y)

        p_j = self.pIndexAlMapa(jasterisk)
        
        d = self.gauss(p_j, sigma)
        dw = learning_rate * np.multiply(d, (x.T - self.weights)) ##### CONSULTAR -> OK
        
        self.weights += dw

    def train(self, dataset, epochs, mode=0):
        self.ninputs = len(dataset[0])
        self.weights = np.random.uniform(-0.5, 0.5, (self.ninputs, self.noutputs))

        for t in xrange(1, epochs+1):
            eta = t ** (- 1/2)
            if mode==0:
                sigma_t = (self.M2/2)* (t ** (-1/3))
            elif mode ==1:
                sigma_t = self.sigma_zero *((1+t*self.sigma_r)**(-self.alfa))     # Mas rapido
            elif mode ==2:
                sigma_t = self.sigma_zero *np.exp(-t/self.sigma_r)
            else:
                sigma_t = self.sigma_zero /(1+t*sigma_zero*self.sigma_r)      # Mas lento

            for x in dataset:
                y = self.activate(np.array(x).reshape((1,856)))
                self.correction(np.array(x).reshape((1,856)), eta, sigma_t, y)

            #if(t%10==0):
            print "epoca: "+str(t)

    def test(self,x):
        y=self.activate(x)
        posicion=np.argmax(y)
        return self.pIndexAlMapa(posicion)	
\end{lstlisting}
